/* GLOBALS :( */
var SETTINGS = new Settings();
var LAYERS = null;
var RedrawRegions = {}; RedrawRegions.all = 0; RedrawRegions.hover = 1; // enum
var REDRAW_REGION = RedrawRegions.all;


void setup()
{
    size(window.innerWidth, window.innerHeight);
    
    SETTINGS.LastFmColors = loadImage('../deps/layers', 'jpg');
    SETTINGS.bounds = null;    
    SETTINGS.layer_colors = [];
    
    background(SETTINGS.colors.background);
    smooth();
    
    window.onresize = function() { REDRAW_REGION = RedrawRegions.all; redraw(); }
    noLoop(); // This needs to be called last.
}


void mouseClicked()
{
    console.log('Click', mouseX, mouseY);
    
    // Did we click the settings?
    if (SETTINGS.bounds !== null && SETTINGS.bounds.contains(mouseX, mouseY))
    {
        // See which setting got the click.
        dance: // You'll see ...
        for (var i = 0; i < SETTINGS.num_types(); i++)
        {
            var setting = SETTINGS.settings[i]; // settings. There, I said it again.
            
            for (var j = 0; j < setting.values.length; j++)
            {
                if (setting.rects[j].contains(mouseX, mouseY))
                {
                    console.log("Changed settings", setting.current, " to ", setting.values[j]);
                    setting.current = setting.values[j];
                    REDRAW_REGION = RedrawRegions.all;
                    redraw();
                    break dance; // see?
                }
            }
        }
    }
}


int getLayerHover()
{
    try
    {
        for (var i = 0; i < LAYERS.length; i++)
            if (LAYERS[i].hover)
                return i;
    } catch(e){} // if LAYERS or hover not set, don't die.
    
    return -1;
}


void mouseMoved()
{
    color hit = get(mouseX, mouseY);
    
    var was_hovering = getLayerHover() != -1;
    
    for (var i = 0; i < SETTINGS.layer_colors.length; i++)
        LAYERS[i].hover = (SETTINGS.layer_colors[i] == hit);
    
    var is_hovering = getLayerHover() != -1;
    
    if (is_hovering != was_hovering || is_hovering)
    {
        REDRAW_REGION = RedrawRegions.hover;
        redraw();
    }
}


void draw()
{
    var m = millis();
    
    if (REDRAW_REGION == RedrawRegions.all)
    {
        try
        {
            size(window.innerWidth, window.innerHeight);
        }
        catch(e)
        {
            // This is a known issue in processing v0.8:
            // https://processing-js.lighthouseapp.com/projects/41284-processingjs/tickets/576
            console.log('expected error: '  + e);
        }
    }
    
    /* Set up screen geometry */
    var text_height = 20;
    var settings_top = height - text_height;
    var legend_bottom = text_height;    
    SETTINGS.bounds = new Rect(0, settings_top, width, text_height);
    
    /* Deal with mouse hover stuff */
    var hover = new Rect(width - 125, 0, 125, text_height);
    if (REDRAW_REGION == RedrawRegions.hover)
    {
        noStroke();
        fill(SETTINGS.colors.background); // erase background
        rect(hover.left, hover.top, hover.width, hover.height + hover.height/4);// descenders
        
        var h = getLayerHover();
        if (0 <= h)
        {
            var i = Math.floor(LAYERS[h].size.length * mouseX / width);
            var val = LAYERS[h].size[i] + 0.00;
            fill(SETTINGS.colors.neutral);
            textFont("Arial", text_height);
            var hover_text = LAYERS[h].name + ': ' + val;
            text(hover_text, hover.left, hover.top + hover.height / 4, hover.width, hover.height);
        }
        return;
    }
    
    /* Import data Dataset*/
    var raw_data = getStreamgraphData();
    var data_labels = getStreamgraphLabels();
    var data = new DataSource(raw_data, data_labels);
    var layers = data.make(data_labels.length, raw_data.length);
    
    /* Calculate */
    var layer_sort = SETTINGS.get('Sort');
    var layers = layer_sort(layers);
    
    var layer_layout = SETTINGS.get('Layout');
    layer_layout(layers);
    
    var color_picker = SETTINGS.get('ColorPicker');
    color_picker(layers, SETTINGS.LastFmColors);
    
    // Just because we have all this space, doesn't mean we should use it all.
    // The graphs tend to look better when they are wider than they are long.
    var h = width / 4;
    if (settings_top - legend_bottom < h)
        h = settings_top - legend_bottom;
    var space = ((settings_top - legend_bottom) - h) / 2;
    
    scaleLayers(layers, legend_bottom + space, settings_top - space);
    
    /* Draw */
    var curve = SETTINGS.get('Curve');
    drawLayers(layers, curve());
    drawLegend(new Rect(0, 0, width - hover.width, legend_bottom), layers);
    drawSettings(SETTINGS.bounds);
    
    /* Used for hit testing */
    SETTINGS.layer_colors = storeColors(layers);
    LAYERS = layers;
    console.log("total time to draw: ", millis() - m);
}


void drawSettings(r)
{
    var spacing = 10; // space between setting groups
    var text_left = r.left;
    var text_width = (r.width - spacing * (SETTINGS.num_types() - 1)) / SETTINGS.num_options();
    var text_height = r.height * .75;
    var text_top = r.bottom() - text_height;
    
    pushStyle();
    colorMode(RGB, 255);
    textFont("Arial", text_height);
    
    for (var i = 0; i < SETTINGS.num_types(); i++)
    {
        var setting = SETTINGS.settings[i]; // settings. There, I said it again.
        var num_values = setting.values.length;
        
        // Draw rect for this setting.
        pushStyle();
        noFill();
        stroke(128);
        strokeWeight(1);
        rect(text_left, r.top, text_width * num_values, r.height);
        popStyle();
        
        setting.rects = []; // Tack on rects for hit-testing.
        for (var j = 0; j < num_values; j++)
        {
            var value = setting.values[j];
            var text_color = (value == setting.current) ? SETTINGS.colors.highlight : SETTINGS.colors.neutral;
            fill(text_color);
            text(value, text_left, text_top, text_width, text_height);
            setting.rects[j] = new Rect(text_left, r.top, text_width, r.height);
            text_left += text_width;
        }
        text_left += spacing;
    }
    popStyle();
}


// Return colorMode, range, color triplet (either in rgb or hsb, specified by colorMode)
Array getColor(layer)
{
    if (layer.hasOwnProperty('hsb'))
        return [HSB, 1.0].concat(layer.hsb);
    
    // assume some variety of rgb
    if (3 < layer.rgb.length) // rgba (image.pixels returns this)
    {
        c = rgbaToInt(layer.rgb);
        return [RGB, 255, red(c), green(c), blue(c)];
    }
    
    return [RGB, 255].concat(layer.rgb);
}


void storeColors(layers)
{
    pushStyle();
    for (var i = 0; i < layers.length; i++)
    {
        var c = getColor(layers[i]);
        colorMode.apply(this, c.slice(0,2));
        stroke.apply(this, c.slice(-3));
        point(width-1, i);
    }
    popStyle();
    return get(width-1, 0, 1, layers.length).pixels;
}


void drawLegend(Rect r, Layers[] layers)
{
    pushStyle();
    
    var left = r.left;
    var entry_width = r.width / layers.length;
    var block_width = .3 * entry_width; // rect
    var text_width = .6 * entry_width; // text
    var space = entry_width - block_width - text_width; // space
    
    textFont("Arial", r.height);
    noStroke();
    for (var i = 0; i < layers.length; i++)
    {
        var layer = layers[i];
        
        var c = getColor(layer); // colorMode, range, color triplet [r, g, b] or  [h, s, b]
        colorMode.apply(this, c.slice(0,2)); // i.e. colorMode(c[0], c[1])
        fill.apply(this, c.slice(-3));       // i.e. fill(c[2], c[3], c[4])
        
        rect(left, r.top, block_width, r.height);
        left += block_width + space;
        
        // + r.height/4 on the line below is a total fudge for alignment in v0.8
        // It wasn't necessary in processing.js v0.6 (just used r.bottom()).
        text(layer.name, left, r.top + r.height / 4, text_width, r.height);
        left += text_width;
    }
    popStyle();
}


void drawLayers(Layers[] layers, boolean isGraphCurved)
{
    int n = layers.length;
    int m = layers[0].size.length;
    int lastIndex = m - 1;
    int lastLayer = n - 1;
    
    background(SETTINGS.colors.background);
    pushStyle();
    noStroke();
    
    // Generate graph.
    for (int i = 0; i < n; i++) 
    {
        Layer layer = layers[i];
        int start = max(0, layer.onset - 1);
        int end   = min(m - 1, layer.end);
        boolean pxl = (i == lastLayer);
        
        var c = getColor(layer); 
        colorMode.apply(this, c.slice(0,2)); // i.e. colorMode(c[0], c[1])
        fill.apply(this, c.slice(-3));       // i.e. fill(c[2], c[3], c[4])
        
        // Draw shape
        beginShape();
        
        // Draw top edge, left to right
        graphVertex(start, layer.yTop, isGraphCurved, pxl);
        for (int j = start; j <= end; j++)
            graphVertex(j, layer.yTop, isGraphCurved, pxl);
        
        graphVertex(end, layer.yTop, isGraphCurved, pxl);
        
        // Draw bottom edge, right to left
        graphVertex(end, layer.yBottom, isGraphCurved, false);
        for (int j = end; j >= start; j--)
            graphVertex(j, layer.yBottom, isGraphCurved, false);
        
        graphVertex(start, layer.yBottom, isGraphCurved, false);
        
        endShape(CLOSE);
    }
    
    popStyle();
}


// TODO: this probably shouldn't be called from graphVertex
void computeLayerSize(n)
{
    // We want to display about 1 data point for every 15 pixels.
    var density = 0.06;
    if (n / width < density)
        return n;
    
    return density * width;
}


void graphVertex(int point, float[] source, boolean curve, boolean pxl)
{
    var layerSize = computeLayerSize(source.length);
    float x = map(point, 0, layerSize - 1, 0, width);
    float y = source[point] - (pxl ? 1 : 0);
    if (curve)
        curveVertex(x, y);
    else
        vertex(x, y);
}


void scaleLayers(Layer[] layers, int screenTop, int screenBottom) 
{
    // Figure out max and min values of layers.
    float lmin = layers[0].yTop[0];
    float lmax = layers[0].yBottom[0];
    for (int i = 0; i < layers[0].size.length; i++)
    {
        for (int j = 0; j < layers.length; j++)
        {
            lmin = min(lmin, layers[j].yTop[i]);
            lmax = max(lmax, layers[j].yBottom[i]);
        }
    }
    
    float scale = (screenBottom - screenTop) / (lmax - lmin);
    for (int i = 0; i < layers[0].size.length; i++)
    {
        for (int j = 0; j < layers.length; j++)
        {
            layers[j].yTop[i] = screenTop + scale * (layers[j].yTop[i] - lmin);
            layers[j].yBottom[i] = screenTop + scale * (layers[j].yBottom[i] - lmin);
        }
    }
}
